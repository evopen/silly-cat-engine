#version 460
#extension GL_EXT_debug_printf : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_ray_query : require

layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, set = 0, rgba32f) uniform image2D storage_image;

layout(binding = 1, set = 0) uniform accelerationStructureEXT tlas;

layout(binding = 2, set = 0, scalar) buffer Vertices
{
    vec3 vertices[];
};
layout(binding = 3, set = 0, scalar) buffer Indices
{
    uint indices[];
};

const uvec2 RESOLUTION = uvec2(800, 600);

const vec3 camera_origin = vec3(-0.001, 1.0, 6.0);
vec3 ray_origin = camera_origin;

vec3 ACESToneMapping(vec3 color, float adapted_lum)
{
    const float A = 2.51f;
    const float B = 0.03f;
    const float C = 2.43f;
    const float D = 0.59f;
    const float E = 0.14f;

    color *= adapted_lum;
    return (color * (A * color + B)) / (color * (C * color + D) + E);
}

void main()
{
    const uvec2 pixel = gl_GlobalInvocationID.xy;
    if ((pixel.x > RESOLUTION.x) || (pixel.y > RESOLUTION.y)) {
        return;
    }

    const vec2 screenUV = vec2(2.0 * (float(pixel.x) + 0.5 - 0.5 * RESOLUTION.x) / RESOLUTION.y, //
        -(2.0 * (float(pixel.y) + 0.5 - 0.5 * RESOLUTION.y) / RESOLUTION.y) // Flip the y axis
    );

    const float fovVerticalSlope = 1.0 / 5.0;
    vec3 rayDirection = vec3(fovVerticalSlope * screenUV.x, fovVerticalSlope * screenUV.y, -1.0);

    rayQueryEXT rayQuery;

    rayQueryInitializeEXT(rayQuery, // Ray query
        tlas, // Top-level acceleration structure
        gl_RayFlagsOpaqueEXT, // Ray flags, here saying "treat all geometry as opaque"
        0xFF, // 8-bit instance mask, here saying "trace against all instances"
        ray_origin, // Ray origin
        0.1, // Minimum t-value
        rayDirection, // Ray direction
        10000.0); // Maximum t-value

    while (rayQueryProceedEXT(rayQuery)) {
    }

    vec3 pixelColor;

    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
        const int primitive_id = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
        pixelColor = vec3(0.0, rayQueryGetIntersectionBarycentricsEXT(rayQuery, true));
        pixelColor.x = 1 - pixelColor.y - pixelColor.z;
    } else {
        // Ray hit the sky
        pixelColor = vec3(0.0, 0.0, 0.5);
    }

    const float t = rayQueryGetIntersectionTEXT(rayQuery, true);

    pixelColor = ACESToneMapping(pixelColor, 1);

    imageStore(storage_image, ivec2(pixel), vec4(pixelColor, 1.0));

    debugPrintfEXT("Color %v3f\n", pixelColor);
}
