#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_debug_printf : require
#extension GL_GOOGLE_include_directive : require

#include "common.glsl"

layout(binding = 0, set = 0, rgba32f) uniform image2D storage_image;
layout(binding = 1, set = 0) uniform accelerationStructureEXT tlas;

// layout(binding = 2, set = 0) uniform Camera
// {
//     vec3 origin;
//     vec3 dir;
// }
// camera;

layout(location = 0) rayPayloadEXT PassableInfo payload;

vec3 sky_color(vec3 dir)
{
    if (dir.y > 0) {
        return mix(vec3(1.0f), vec3(0.25f, 0.5f, 1.0f), dir.y);
    } else {
        return vec3(0.03);
    }
}

vec3 ACESToneMapping(vec3 color, float adapted_lum)
{
    const float A = 2.51f;
    const float B = 0.03f;
    const float C = 2.43f;
    const float D = 0.59f;
    const float E = 0.14f;

    color *= adapted_lum;
    return (color * (A * color + B)) / (color * (C * color + D) + E);
}

void main()
{
    const vec2 resolution = imageSize(storage_image);
    const ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);

    if ((pixel.x >= resolution.x) || (pixel.y >= resolution.y)) {
        return;
    }

    // This scene uses a right-handed coordinate system like the OBJ file format, where the
    // +x axis points right, the +y axis points up, and the -z axis points into the screen.
    // The camera is located at (-0.001, 0, 53).
    const vec3 cameraOrigin = vec3(-0.001, 1.0, 6.0);
    // Define the field of view by the vertical slope of the topmost rays:
    const float fovVerticalSlope = 1.0 / 5.0;

    const vec2 screenUV = vec2(2.0 * (float(pixel.x) + 0.5 - 0.5 * resolution.x) / resolution.y, //
        -(2.0 * (float(pixel.y) + 0.5 - 0.5 * resolution.y) / resolution.y) // Flip the y axis
    );

    vec3 rayDirection = normalize(vec3(fovVerticalSlope * screenUV.x, fovVerticalSlope * screenUV.y, -1.0));

    float tmin = 0.001;
    float tmax = 10000.0;

    vec3 accumulatedRayColor = vec3(1.0);
    vec3 pixel_color = vec3(0.3);
    for (int traced_segment = 0; traced_segment < 1; traced_segment++) {
        traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0, cameraOrigin, tmin, rayDirection, tmax, 0);

        if (payload.rayHitSky) {
            pixel_color = accumulatedRayColor * sky_color(rayDirection);
            break;
        } else {
            accumulatedRayColor *= payload.color;
            pixel_color = accumulatedRayColor;
        }
    }

    pixel_color = ACESToneMapping(pixel_color, 1);

    imageStore(storage_image, pixel, vec4(pixel_color, 1.0));
}
